{"version":3,"sources":["components/ControlBar/ControlButton.jsx","components/ControlBar/ControlSlider.jsx","components/ControlBar/ControlBar.jsx","hooks/useCanvas.js","components/Canvas/Canvas.jsx","graph/Vertex.js","graph/RandomEulerGraph.js","components/Canvas/DrawElements.js","components/Canvas/DrawLogic.js","App.js","index.js"],"names":["ControlButton","props","className","onClick","clickFunc","name","ControlSlider","useState","value","setValue","type","min","max","onChange","e","target","onNumVertChange","ControlBar","genGraphFunc","softReset","openHelp","canvasWidth","window","innerWidth","canvasHeight","innerHeight","frameCount","then","Date","now","useCanvas","draw","getGraphData","setSuccess","canvasRef","useRef","useEffect","animationFrameId","canvas","current","context","getContext","width","height","render","elapsed","vertexList","edgeList","mouseXy","clickXy","requestAnimationFrame","cancelAnimationFrame","Canvas","graphData","ref","Vertex","id","this","_id","_xy","xy","genRandom","minimum","maximum","Math","floor","random","checkDistance","pointA","pointB","sqrt","pow","abs","getAngle","mainPoint","acos","PI","genDegreeSequence","totalNumber","hasOddNumbers","oddNumber","oddCounter","sequence","i","degree","ceil","push","generateEdges","degreeSequence","vertices","counter","length","remainingConnections","sort","a","b","edges","x","y","start","end","currentState","sum","reduce","vertexDistanceToEdge","edge","vertex","edgeLength","startToPoint","endToPoint","generateCoords","size","allVertecies","coordinates","tooClose","j","RandomEulerGraph","numberOfVertices","canvasSize","Array","keys","map","z","numberOfRetries","problemVercies","defaultVertex","ctx","fillStyle","arc","fill","beginPath","activeVertex","angle","pastVertex","hoverVertex","sin","possibleVertex","defaultEdge","moveTo","lineTo","strokeStyle","lineWidth","stroke","possibleEdge","pastEdge","currentActive","vertexHistory","listOfPossibleVertecies","hasStarted","hasWon","resetGraphStatus","checkEdgePosibilties","currentVertex","clearRect","fillRect","totalUsedEdges","targetX","targetY","Object","forEach","key","Modal","setAppElement","canceledWin","numberOfVertecies","handleNumVertChange","val","parseInt","genGraph","softResetGraph","App","helpIsOpen","setHelpIsOpen","successIsOpen","setSuccessIsOpen","overlayClassName","isOpen","onRequestClose","onMouseMove","clientX","clientY","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.f8c84479.chunk.js","sourcesContent":["import React from 'react';\r\nimport './ControlButton.css'\r\n\r\nconst ControlButton = (props) => {\r\n    return (\r\n        <button className=\"controlButton\" onClick={props.clickFunc}>\r\n            {props.name}\r\n        </button>\r\n    );\r\n};\r\n\r\nexport default ControlButton;","import React, {useState} from 'react';\r\nimport './ControlSlider.css'\r\n\r\nconst ControlSlider = (props) => {\r\n    const [value, setValue] = useState(5);\r\n\r\n    const handleChange = (e) => {\r\n        setValue(e.target.value);\r\n        props.onNumVertChange(e.target.value);\r\n    }\r\n    return (\r\n        <div className=\"controlSlider_main\">\r\n            <div className=\"sliderText\">{value}</div>\r\n            <div className=\"sliderDiv\">\r\n                <input type=\"range\" min=\"4\" max=\"17\" value={value} className=\"slider\" onChange={handleChange} />\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default ControlSlider;","import React from 'react';\r\nimport './ControlBar.css'\r\nimport ControlButton from './ControlButton'\r\nimport ControlSlider from './ControlSlider'\r\n\r\nconst ControlBar = (props) => {\r\n    return (\r\n        <header className=\"controlBar\">\r\n            <nav className=\"controlBar_nav\">\r\n                <button className=\"difficulty_tag\">Difficulty</button>\r\n                <ControlSlider onNumVertChange={props.onNumVertChange}/>\r\n                <ControlButton name=\"New\" clickFunc={props.genGraphFunc}/>\r\n                <ControlButton name=\"Reset\" clickFunc={props.softReset}/>\r\n                <ControlButton name=\"Help\" clickFunc={props.openHelp}/>\r\n                \r\n            </nav>\r\n        </header>\r\n    );\r\n};\r\n\r\nexport default ControlBar;","import { useRef, useEffect } from 'react'\r\n\r\nexport const canvasWidth = window.innerWidth - 30;\r\nexport const canvasHeight = window.innerHeight - 75;\r\n\r\nlet frameCount = 0;\r\nconst FPS_INTERVAL = 1000 / 60; //60FPS cap\r\nlet then = Date.now()\r\n\r\nconst useCanvas = (draw, getGraphData, setSuccess) => {\r\n\r\n\tconst canvasRef = useRef(null);\r\n\r\n\tuseEffect(() => {\r\n\t\tconst canvas = canvasRef.current;\r\n\t\tconst context = canvas.getContext('2d');\r\n\t\tlet animationFrameId;\r\n\t\tcanvas.width = window.innerWidth - 30;\r\n\t\tcanvas.height = window.innerHeight - 75;\r\n\r\n\t\tconst render = () => {\r\n\t\t\tconst now = Date.now();\r\n\t\t\tconst elapsed = now - then;\r\n\t\t\tif (elapsed > FPS_INTERVAL) {\r\n\t\t\t\tthen = now - (elapsed % FPS_INTERVAL);\r\n\t\t\t\tframeCount++;\r\n\t\t\t\tlet { vertexList, edgeList, mouseXy, clickXy } = getGraphData();\r\n\t\t\t\tif (draw(context, frameCount, vertexList, edgeList, mouseXy, clickXy)) { setSuccess() }\r\n\t\t\t}\r\n\t\t\tanimationFrameId = window.requestAnimationFrame(render);\r\n\t\t}\r\n\t\trender()\r\n\r\n\t\treturn () => {\r\n\t\t\twindow.cancelAnimationFrame(animationFrameId);\r\n\t\t}\r\n\t}, [draw, getGraphData, setSuccess])\r\n\r\n\treturn [canvasRef];\r\n}\r\n\r\nexport default useCanvas;","import React from 'react';\r\nimport useCanvas, { canvasHeight, canvasWidth } from '../../hooks/useCanvas';\r\n\r\nconst Canvas = (props) => {\r\n    const { draw, graphData, setSuccess } = props;\r\n    const [canvasRef] = useCanvas(draw, graphData, setSuccess);\r\n\r\n    return (<canvas ref={canvasRef} />);\r\n};\r\n\r\nexport const getWindow = () => {\r\n    return [canvasWidth, canvasHeight];\r\n};\r\n\r\nexport default Canvas;","export default class Vertex {\r\n    constructor(id) {\r\n        this._id = id;\r\n        this._xy = null;\r\n    }\r\n    get id() {\r\n        return this._id;\r\n    }\r\n    get xy() {\r\n        return this._xy;\r\n    }\r\n    \r\n    /** @param {number[]} xy */\r\n    set xy(xy) {\r\n        this._xy = xy;\r\n    }\r\n}","import Vertex from './Vertex';\r\n\r\n// Generate random number between min and max, inclusive\r\nconst genRandom = (minimum, maximum) => {\r\n    return minimum + (Math.floor(Math.random()*(maximum-minimum+1)));\r\n}\r\n\r\n// Gets distance between two points\r\nexport const checkDistance = (pointA, pointB) => {\r\n    return Math.sqrt(Math.pow(Math.abs(pointA[0]-pointB[0]), 2) + Math.pow(Math.abs(pointA[1]-pointB[1]), 2));\r\n};\r\n\r\n// Gets angle between edge (mainPoint, pointA) and target (pointB)\r\nconst getAngle = (mainPoint, pointA, pointB) => {\r\n    return  Math.acos(((pointA[0]-mainPoint[0]) * (pointB[0]-mainPoint[0]) + (pointA[1]-mainPoint[1]) * (pointB[1]-mainPoint[1])) / \r\n            (Math.sqrt(Math.pow(pointA[0]-mainPoint[0], 2) + Math.pow(pointA[1]-mainPoint[1], 2)) * \r\n            Math.sqrt(Math.pow(pointB[0]-mainPoint[0], 2) + Math.pow(pointB[1]-mainPoint[1], 2))))*(180/Math.PI);\r\n}\r\n\r\n// Generate sequence of degrees that conform to Euler's Path\r\nconst genDegreeSequence = (totalNumber, hasOddNumbers) => {\r\n    let oddNumber = null;\r\n    let oddCounter = 0;\r\n    if (hasOddNumbers === true) {\r\n        oddNumber = (genRandom(1, Math.floor(totalNumber / 2) - 1) * 2) + 1;\r\n        oddCounter = 2;\r\n    }\r\n    let sequence = [];\r\n    for (let i = 0; i < totalNumber; i++) {\r\n        let degree = 0;\r\n        if (oddCounter > 0) {\r\n            degree = oddNumber;\r\n            oddCounter--;\r\n        }\r\n        else {\r\n            degree = (genRandom(1, Math.ceil(totalNumber / 2) - 1) * 2);\r\n        }\r\n        sequence.push(degree);\r\n    }\r\n    return sequence;\r\n}\r\n\r\n// Generate edges in pairs {start: V1, end: V2}\r\nconst generateEdges = (degreeSequence, vertices) => {\r\n    const counter = [];\r\n    for (let i = 0; i<degreeSequence.length; i++) {\r\n        counter.push({id: i, remainingConnections: degreeSequence[i]});\r\n    }\r\n    counter.sort((a, b) => { return b.remainingConnections - a.remainingConnections });\r\n\r\n    let edges = [];\r\n    for (let x = 0; x < counter.length; x++) {\r\n        for (let y = counter[0].remainingConnections; y>0; y--) {\r\n            counter[y].remainingConnections--;\r\n            edges.push({ start: vertices[counter[0].id], end: vertices[counter[y].id], currentState: 0 });\r\n        }\r\n        counter[0].remainingConnections = 0;\r\n        counter.sort((a, b) => { return b.remainingConnections - a.remainingConnections });\r\n    }\r\n\r\n    const sum = degreeSequence.reduce((a, b) => a + b, 0);\r\n    if (edges.length !== sum/2 || counter[counter.length-1] < 0) { \r\n        edges = [-1];\r\n    }\r\n    return edges;\r\n}\r\n\r\n// Returns distance from the vertex, to the nearest point on the edge\r\nconst vertexDistanceToEdge = (edge, vertex) => {\r\n    if (getAngle(edge.start.xy, edge.end.xy, vertex) >= 90) {\r\n        return checkDistance(edge.start.xy, vertex)\r\n    }\r\n    if (getAngle(edge.end.xy, edge.start.xy, vertex) >= 90) {\r\n        return checkDistance(edge.end.xy, vertex)\r\n    }\r\n    else {\r\n        const edgeLength = checkDistance(edge.start.xy, edge.end.xy);\r\n        const startToPoint = checkDistance(edge.start.xy, vertex);\r\n        const endToPoint = checkDistance(edge.end.xy, vertex);\r\n        const area = 0.25*Math.sqrt((edgeLength + startToPoint + endToPoint) * (-edgeLength + startToPoint + endToPoint) * (edgeLength - startToPoint + endToPoint) * (edgeLength + startToPoint - endToPoint));\r\n        const distance = 2*area/edgeLength;\r\n        return distance;\r\n    }\r\n}\r\n\r\n// Generates integer coordinates [x, y] for each vertex in vertices\r\nconst generateCoords = (vertices, size, allVertecies) => {\r\n    for (let i = 0; i < vertices.length; i++) {\r\n        let coordinates = null;\r\n        while (true) {\r\n            coordinates = [genRandom(0, size[0]-45), genRandom(0, size[1]-40)];\r\n            let tooClose = false;\r\n            for (let j = 0; j<allVertecies.length; j++) {\r\n                if (allVertecies[j].xy === null) { continue; }\r\n                let distance = checkDistance(coordinates, allVertecies[j].xy)\r\n                if (distance < 50) { tooClose = true }\r\n            }\r\n            if (tooClose === false) { break; }\r\n        }\r\n        vertices[i].xy = coordinates;\r\n    }\r\n}\r\n\r\n// Overall function, generates entire graph.\r\n// Returns set of vertices V, and set of edges E => [V, E]\r\nconst RandomEulerGraph = (numberOfVertices, canvasSize) => {\r\n    const odd = true;\r\n    const vertexList = [...Array(numberOfVertices).keys()].map(z => new Vertex(z));\r\n    let degreeSequence = null;\r\n    let edgeList = [-1];\r\n    while (edgeList[0] === -1) {\r\n        degreeSequence = genDegreeSequence(numberOfVertices, odd).sort((a, b) => { return b - a });\r\n        edgeList = generateEdges(degreeSequence, vertexList);\r\n    }\r\n    generateCoords(vertexList, canvasSize, vertexList);\r\n    let numberOfRetries = 0;\r\n    // Re-generate any vertex that is too close to an existing edge\r\n    while (true) {\r\n        let problemVercies = [];\r\n        for (let i = 0; i<edgeList.length; i++) {\r\n            for (let j = 0; j<vertexList.length; j++) {\r\n                if (vertexList[j] === edgeList[i].start || vertexList[j] === edgeList[i].end) { continue; }\r\n                let distance = vertexDistanceToEdge(edgeList[i], vertexList[j].xy)\r\n                if (distance < 15) { problemVercies.push(vertexList[j]); }\r\n            }\r\n        }\r\n        if (problemVercies.length === 0) { break; }\r\n        if (numberOfRetries > 100) { \r\n            generateCoords(vertexList, canvasSize, vertexList); \r\n            numberOfRetries = 0;\r\n        }\r\n        else { generateCoords(problemVercies, canvasSize, vertexList); }\r\n        numberOfRetries++;\r\n    }\r\n    return [vertexList, edgeList];\r\n}\r\n\r\nexport default RandomEulerGraph;","// Draw functions for all possible vertex states\r\nexport const defaultVertex = (ctx, x, y) => {\r\n    ctx.fillStyle = '#2b2b2b'\r\n    ctx.arc(x, y, 12, 0, 2*Math.PI);\r\n    ctx.fill();\r\n    ctx.beginPath();\r\n    ctx.fillStyle = '#000000'\r\n    ctx.arc(x, y, 10, 0, 2*Math.PI);\r\n    ctx.fill()\r\n}\r\n\r\nexport const activeVertex = (ctx, x, y, frameCount) => {\r\n    ctx.fillStyle = '#f7e9c8';\r\n    let angle = (2*Math.PI/180)*(frameCount%180);\r\n    ctx.arc(x, y, 12, angle, angle+Math.PI);\r\n    ctx.fill()\r\n    ctx.beginPath()\r\n    ctx.fillStyle = '#ffa500';\r\n    ctx.arc(x, y, 10, 0, 2 * Math.PI);\r\n    ctx.fill()\r\n}\r\n\r\nexport const pastVertex = (ctx, x, y) => {\r\n    ctx.fillStyle = '#f7e9c8'\r\n    ctx.arc(x, y, 11, 0, 2*Math.PI);\r\n    ctx.fill()\r\n    ctx.beginPath()\r\n    ctx.fillStyle = '#0ccef5'\r\n    ctx.arc(x, y, 10, 0, 2*Math.PI);\r\n    ctx.fill()\r\n}\r\n\r\nexport const hoverVertex = (ctx, x, y, frameCount) => {\r\n    ctx.fillStyle = '#f7e9c8'\r\n    ctx.arc(x, y, 10+Math.sin(frameCount*0.085)**2, 0, 2*Math.PI);\r\n    ctx.fill()\r\n}\r\n\r\nexport const possibleVertex = (ctx, x, y, frameCount) => {\r\n    ctx.fillStyle = '#faeb48'\r\n    ctx.arc(x, y, 10+Math.sin(frameCount*0.05)**2, 0, 2*Math.PI);\r\n    ctx.fill()\r\n}\r\n\r\n// Draw functions for all possible edge states\r\nexport const defaultEdge = (ctx, edge) => {\r\n    ctx.beginPath()\r\n    ctx.moveTo(edge.start.xy[0]+15, edge.start.xy[1]+15)\r\n    ctx.lineTo(edge.end.xy[0]+15, edge.end.xy[1]+15)\r\n    ctx.strokeStyle = '#080808';\r\n    ctx.lineWidth = 2;\r\n    ctx.stroke();\r\n}\r\n\r\nexport const possibleEdge = (ctx, edge) => {\r\n    ctx.beginPath()\r\n    ctx.moveTo(edge.start.xy[0]+15, edge.start.xy[1]+15)\r\n    ctx.lineTo(edge.end.xy[0]+15, edge.end.xy[1]+15)\r\n    ctx.strokeStyle = '#d4a20d';\r\n    ctx.lineWidth = 2;\r\n    ctx.stroke();\r\n}\r\n\r\nexport const pastEdge = (ctx, edge) => {\r\n    ctx.beginPath()\r\n    ctx.moveTo(edge.start.xy[0]+15, edge.start.xy[1]+15)\r\n    ctx.lineTo(edge.end.xy[0]+15, edge.end.xy[1]+15)\r\n    ctx.strokeStyle = '#006187';\r\n    ctx.lineWidth = 3;\r\n    ctx.stroke();\r\n    ctx.beginPath()\r\n    ctx.moveTo(edge.start.xy[0]+15, edge.start.xy[1]+15)\r\n    ctx.lineTo(edge.end.xy[0]+15, edge.end.xy[1]+15)\r\n    ctx.strokeStyle = '#09a3e0';\r\n    ctx.lineWidth = 2;\r\n    ctx.stroke();\r\n}","import {checkDistance} from '../../graph/RandomEulerGraph';\r\nimport {defaultVertex, hoverVertex, pastVertex, activeVertex, possibleVertex, defaultEdge, possibleEdge, pastEdge} from './DrawElements';\r\n\r\nlet currentActive = null;\r\nlet vertexHistory = {};\r\nlet listOfPossibleVertecies = {}; // Each Obj = {Vertex.id: x, Edge: y}\r\nlet hasStarted = false;\r\nlet hasWon = false;\r\n\r\n\r\nexport const resetGraphStatus = () => {\r\n    currentActive = null;\r\n    vertexHistory = {};\r\n    listOfPossibleVertecies = {};\r\n    hasStarted = false;\r\n    hasWon = false;\r\n};\r\n\r\nconst checkEdgePosibilties = (currentVertex, edgeList) => {\r\n    // Loop through vertex list\r\n    listOfPossibleVertecies = {};\r\n    for (let i = 0; i<edgeList.length; i++) {\r\n        if (edgeList[i].start === currentVertex) { \r\n            if (edgeList[i].currentState === 0) {\r\n                listOfPossibleVertecies[edgeList[i].end.id] = edgeList[i];\r\n                edgeList[i].currentState = 1;\r\n            }\r\n        }\r\n        if (edgeList[i].end === currentVertex) {\r\n            if (edgeList[i].currentState === 0) {\r\n                listOfPossibleVertecies[edgeList[i].start.id] = edgeList[i];\r\n                edgeList[i].currentState = 1;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nexport const draw = (ctx, frameCount, vertexList, edgeList, mouseXy, clickXy) => {\r\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n    ctx.fillStyle = '#292929';\r\n    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n\r\n    // Draws edges\r\n    let totalUsedEdges = 0;\r\n    for (let i = 0; i<edgeList.length; i++) {\r\n        switch(edgeList[i].currentState) {\r\n            case 1:\r\n                possibleEdge(ctx, edgeList[i]);\r\n                break;\r\n            case 2:\r\n                totalUsedEdges++;\r\n                pastEdge(ctx, edgeList[i]);\r\n                break;\r\n            case 0:\r\n                defaultEdge(ctx, edgeList[i]);\r\n                break;\r\n            default:\r\n                defaultEdge(ctx, edgeList[i]);\r\n        }\r\n    }\r\n    if (totalUsedEdges === edgeList.length) {\r\n        hasWon = true;\r\n    }\r\n\r\n    // Draws vertices\r\n    for (let i = 0; i<vertexList.length; i++) {\r\n        ctx.beginPath()\r\n        const targetX = vertexList[i].xy[0]+15;\r\n        const targetY = vertexList[i].xy[1]+15;\r\n        // If vertex is currently active\r\n        if (vertexList[i] === currentActive) {\r\n            activeVertex(ctx, targetX, targetY, frameCount);\r\n        }\r\n        // If vertex will become currently active\r\n        else if (checkDistance([targetX, targetY], [clickXy[0], clickXy[1]]) <= 13 && (listOfPossibleVertecies[vertexList[i].id] || !hasStarted)) {\r\n            // eslint-disable-next-line\r\n            Object.keys(listOfPossibleVertecies).forEach((key) => {\r\n                listOfPossibleVertecies[key].currentState = 0;\r\n            });\r\n            if (listOfPossibleVertecies[vertexList[i].id]) { listOfPossibleVertecies[vertexList[i].id].currentState = 2; }\r\n            listOfPossibleVertecies = {};\r\n            currentActive = vertexList[i];\r\n            vertexHistory[[targetX, targetY]] = true;\r\n            activeVertex(ctx, targetX, targetY, frameCount);\r\n            checkEdgePosibilties(vertexList[i], edgeList);\r\n            if (!hasStarted) { hasStarted = true }\r\n        }\r\n        // If mouse hovering over vertex\r\n        else if (checkDistance([targetX, targetY], [mouseXy[0], mouseXy[1]]) <= 13) {\r\n            hoverVertex(ctx, targetX, targetY, frameCount);\r\n        }\r\n        // If the vertex is a valid selection from current active\r\n        else if (listOfPossibleVertecies[vertexList[i].id] || !hasStarted) {\r\n            possibleVertex(ctx,targetX, targetY, frameCount);\r\n        }\r\n        // If vertex has been activated\r\n        else if (vertexHistory[[targetX, targetY]]) {\r\n            pastVertex(ctx, targetX, targetY);\r\n        }\r\n        // Otherwise vertex untouched\r\n        else {\r\n            defaultVertex(ctx, targetX, targetY);\r\n        }\r\n    }\r\n    if (hasWon) { return true }\r\n};","import React, {useState} from 'react';\nimport \"./App.css\";\nimport ControlBar from './components/ControlBar/ControlBar';\nimport Canvas, {getWindow} from './components/Canvas/Canvas';\nimport RandomEulerGraph from './graph/RandomEulerGraph';\nimport {draw, resetGraphStatus} from './components/Canvas/DrawLogic';\nimport Modal from 'react-modal';\n\nModal.setAppElement('#root');\nlet canceledWin = false;\n\nlet numberOfVertecies = 5;\nconst handleNumVertChange = (val) => {\n\tnumberOfVertecies = parseInt(val, 10);\n}\n\nlet vertexList, edgeList;\nconst genGraph = () => {\n\t[vertexList, edgeList] = RandomEulerGraph(numberOfVertecies, getWindow());\n\tresetGraphStatus();\n\tcanceledWin = false;\n};\ngenGraph();\n\nconst softResetGraph = () => {\n\tresetGraphStatus();\n\tfor (let i=0; i<edgeList.length; i++) {\n\t\tedgeList[i].currentState = 0;\n\t}\n\tmouseXy = [0, 0];\n\tclickXy = [0, 0]; \n}\n\nlet mouseXy = [0, 0];\nlet clickXy = [0, 0]; \nconst App = () => {\n\tconst getMouseCoords = (e) => {\n\t\tmouseXy = [e.clientX-20, e.clientY-65];\n\t}\n\tconst getCoordsOnClick = (e) => {\n\t\tclickXy = [e.clientX-20, e.clientY-65];\n\t}\n\tconst getGraphData = () => {\n\t\treturn {vertexList, edgeList, mouseXy, clickXy};\n\t};\n\n\tconst [helpIsOpen, setHelpIsOpen] = useState(false);\n\tconst openHelpModal = () => {\n\t\tsetHelpIsOpen(true);\n\t}\n\n\tconst [successIsOpen, setSuccessIsOpen] = useState(false);\n\tconst openSuccessModal = () => {\n\t\tif (!canceledWin) { setSuccessIsOpen(true) }\n\t}\n\treturn (\n\t\t<div className=\"main\">\n\t\t\t<Modal \n\t\t\t\tclassName=\"help_modal_content\"\n\t\t\t\toverlayClassName=\"help_modal_overlay\"\n\t\t\t\tisOpen={helpIsOpen} \n\t\t\t\tonRequestClose={()=>setHelpIsOpen(false)}\n\t\t\t>\n\t\t\t\t<div className=\"help_modal_header\">\n\t\t\t\t\t<div className=\"help_modal_header_text\">Help</div>\n\t\t\t\t\t<button className=\"help_modal_close\" onClick={()=>setHelpIsOpen(false)}>X</button>\n\t\t\t\t</div>\n\t\t\t\t<div className=\"help_modal_text\">\n\t\t\t\t\tThe goal is to connect all of the dots, using all of the given paths. You're not allowed to reuse any paths. Click on any point to get started!<br /><br />\n\t\t\t\t\tPossible paths are highlighted orange, used paths are blue, and unavailable paths are black. <br />\n\t\t\t\t\t<ul> The 'New' button generates a new set of paths. </ul>\n\t\t\t\t\t<ul> The 'Reset' button resets the current puzzle to it's starting state. </ul>\n\t\t\t\t\t<ul> The slider is used to choose the number of points. </ul><br />\n\t\t\t\t\tIf you're having any sizing issues, try refreshing the page.\n\t\t\t\t</div>\n\t\t\t</Modal>\n\t\t\t<Modal\n\t\t\t\tclassName=\"success_modal_content\"\n\t\t\t\toverlayClassName=\"success_modal_overlay\"\n\t\t\t\tisOpen={successIsOpen}\n\t\t\t\tonRequestClose={()=> { canceledWin = true; setSuccessIsOpen(false);}}\n\t\t\t>\n\t\t\t\t<div className=\"maybe\">\n\t\t\t\t\t<div className=\"success_modal_top\">Success!</div>\n\t\t\t\t\t<div className=\"success_modal_question\">Start new puzzle?</div>\n\t\t\t\t\t<div className=\"success_modal_new\">\n\t\t\t\t\t\t<button className=\"success_modal_button\" onClick={() => {genGraph(); setSuccessIsOpen(false)}}>New Puzzle</button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</Modal>\n\t\t\t<ControlBar genGraphFunc={genGraph} onNumVertChange={handleNumVertChange} softReset={softResetGraph} openHelp={(openHelpModal)}/>\n\t\t\t<div className=\"main_canvas\" onMouseMove={getMouseCoords} onClick={getCoordsOnClick}>\n\t\t\t\t<main className=\"canvas\">\n\t\t\t\t\t<Canvas draw={draw} graphData={getGraphData} setSuccess={openSuccessModal}/>\n\t\t\t\t</main>\n\t\t\t</div>\n\t\t</div>\n\t)\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}